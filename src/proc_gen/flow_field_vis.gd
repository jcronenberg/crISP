class_name FlowFieldVisualization
extends Node2D
## A simple visualization for a flowfield generated by noise.
##
## Requires [member noise] and [member arrow_image] to be set in the editor.

@export var enabled: bool:
	set(value):
		enabled = value
		if enabled:
			generate_grid()
		else:
			for arrows_1d in _arrows:
				for arrow in arrows_1d as Array[Sprite2D]:
					arrow.queue_free()

			_arrows = []

enum Direction {
	UP = 0,
	RIGHT = 90,
	DOWN = 180,
	LEFT = 270,
}
@export var direction: Direction:
	set(value):
		direction = value
		generate_grid()

@export var arrow_image: Texture2D:
	set(value):
		arrow_image = value
		_arrow_sprite = Sprite2D.new()
		_arrow_sprite.texture = arrow_image
		_arrow_sprite.scale = Vector2(cell_size) / arrow_image.get_size()

@export var noise: NoiseTexture2D:
	set(value):
		noise = value
		generate_grid()

@export var grid_size: Vector2i = Vector2i(128, 128)
@export var cell_size: Vector2i = Vector2i(20, 20)

var _arrow_sprite: Sprite2D
var _arrows: Array[Array] = []


var sample_points: Array[Vector2] = [Vector2(0, 0), Vector2(200, 200), Vector2(21, 78)]
var samples: Array[float] = [0.0, 0.0, 0.0]
func _physics_process(_delta: float) -> void:
	if not enabled:
		return
	var regen_grid: bool = false
	for i in sample_points.size():
		var sample: float = noise.get_noise().get_noise_2dv(sample_points[i])
		if sample != samples[i]:
			regen_grid = true
			samples[i] = sample
			print(sample)

	if regen_grid:
		generate_grid()


## Generate the grid of arrows in the flow field
func generate_grid() -> void:
	if not enabled or not noise or not arrow_image:
		return

	var gen_grid: bool = _arrows.size() == 0
	if gen_grid:
		_arrows.resize(grid_size.x)
	for i in grid_size.x:
		var i_array: Array = _arrows[i]
		if gen_grid:
			i_array.resize(grid_size.y)
		for j in grid_size.y:
			if gen_grid:
				@warning_ignore("integer_division")
				i_array[j] = _generate_arrow_at(Vector2i(i * cell_size.x + cell_size.x / 2, j * cell_size.y + cell_size.y / 2))
			_rotate_arrow_to_noise(i_array[j], Vector2i(i, j))

		_arrows[i] = i_array


func _generate_arrow_at(pos: Vector2i) -> Sprite2D:
	var new_arrow: Sprite2D = _arrow_sprite.duplicate()
	add_child(new_arrow)
	new_arrow.global_position = pos
	return new_arrow


func _rotate_arrow_to_noise(arrow: Node2D, pos: Vector2i) -> void:
	arrow.rotation_degrees = direction + noise.get_noise().get_noise_2dv(pos) * 45
